<!-- Chrome Canvas Fullscreen - F11 to toggle fullscreen -->
<body style="margin: 0;">
<canvas id="canvas" width="480" height="270" style="image-rendering: pixelated; object-fit: contain; width:100%; max-width: 100%; height: 100%; max-height: 100%;">
</canvas>
<script type="module">
    const canvas = document.getElementById('canvas');
    const c = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;



    function clearScreen(c) {
        c.fillStyle = 'black';
        c.fillRect(0, 0, w, h);
    }

    // https://stackoverflow.com/a/28866825
    // doctest?! Explain
    function isIntersecting(p1, p2, p3, p4) {
        function CCW(p1, p2, p3) {
            //return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
            return (p3[1] - p1[1]) * (p2[0] - p1[0]) > (p2[1] - p1[1]) * (p3[0] - p1[0]);
        }
        return (CCW(p1, p3, p4) != CCW(p2, p3, p4)) && (CCW(p1, p2, p3) != CCW(p1, p2, p4));
    }




    class Polygon {
        constructor() {
            this.points = [];
        }
        addPoint(point) {
            this.points.push([...point]);
        }
        * lines() {
            if (!this.points.length) {return;}
            let b = undefined;
            for (let a of this.points) {
                if (a && b) {
                    yield [a, b];
                }
                b = a;
            }
            yield [...b, ...this.points[0]];
        }
        isInside(point) {
            let intersections = 0;
            for (let line of this.lines()) {
                if (isIntersecting(...line, point, [-100, -100])) {  // kind of rubbish hard coding ... maybe use int.min?
                    intersections++;
                    //console.log("oow"); // something up here
                }
            }
            return intersections % 2;  // return 0 for no collision and 1 for collision
        }
        get Path2D() {
            //debugger;
            const p = new Path2D();
            if (!this.points.length) {return p;}
            // duplicated from lines? optimise
            let b = undefined;
            for (let a of this.points) {
                if (!b) {p.moveTo(...a)}
                else {p.lineTo(...a);}
                b = a ;
            }
            p.lineTo(...this.points[0]);
            return p;
        }
    }

    class Bullet {
        constructor(point, velocity) {
            this.point_current = [...point];
            this.point_previous = [...point];
            this.velocity = [...velocity];
        }
        get points() {
            return [this.point_current, this.point_previous];
        }
        get point() {
            return this.point_current;
        }
        set point(point) {
            this.point_previous.splice(0,2, ...this.point_current);
            this.point_current.splice(0,2, ...point);
        }
        move() {
            this.point = [
                this.point_current[0] + this.velocity[0],
                this.point_current[1] + this.velocity[1],
            ];
        }
    }


    const screenPoly = new Polygon();
    for (let p of [
        [0,0],
        [50,0],
        [50,50],
        [0,50],
    ]) {
        screenPoly.addPoint(p);
    }
    


    const state = {
        running: true,
        frame: 0,
        input: {
        },
        gun: {
            pos: [100, 100],
            length: 20,
            angle: Math.PI,
            angle_min: Math.PI - (Math.PI/2),
            angle_max: Math.PI + (Math.PI/2),
            fire: false,
        },
        bullets: [],
        screen: screenPoly,
        xx: 50,
    };


    document.addEventListener('mouseup', () => state.gun.fire = false, false);
    document.addEventListener('mousedown', () => state.gun.fire = true, false);
    document.addEventListener("pointermove", (e) => {
        //console.log(-e.movementX, e.movementY);
        state.gun.angle += e.movementX/180;
        state.gun.angle = Math.max(Math.min(state.gun.angle, state.gun.angle_max), state.gun.angle_min);
    }, false);


    function setRunning(running) {state.running = running; console.log("running", running); requestAnimationFrame(main);}
    window.addEventListener("focus", () => {setRunning(true)}, false);
    window.addEventListener("blur", () => {setRunning(false)}, false);


    //-----------

    function gun_tip_pos(gun) {
        const [x, y, length, angle] = [...gun.pos, gun.length, gun.angle];
        return [
            x + (Math.sin(angle) * length),
            y + (Math.cos(angle) * length),
        ];
    }

    //------------


    function incrementModel(state) {
        if (state.gun.fire && state.frame % 8 == 0) {
            const v = 1;
            const angle = state.gun.angle;
            state.bullets.push(
                new Bullet(
                    gun_tip_pos(state.gun), // used named params here?
                    [Math.sin(angle) * v, Math.cos(angle) * v],
                )
            );
        }

        for (let bullet of state.bullets) {
            bullet.move();
        }

        state.frame++;
    }
    function render(c, state) {
        clearScreen(c);

        // Test
        c.fillStyle = 'yellow';
        c.fillRect(state.xx, 50, 10, 10);
        if (state.gun.fire) {state.xx++;}

        c.strokeStyle = 'green';
        c.lineWidth = 2;
        c.stroke(state.screen.Path2D);

        // Gun
        const [x, y, length, angle] = [...state.gun.pos, state.gun.length, state.gun.angle];
        c.beginPath();
        c.strokeStyle = 'red';
        c.lineWidth = 5;
        c.moveTo(x, y);
        c.lineTo(
            x + Math.sin(angle) * length,
            y + Math.cos(angle) * length,
        );
        c.stroke();

        // Bullets
        for (let bullet of state.bullets) {
            c.fillStyle = 'white';
            if (state.screen.isInside(bullet.point)) {
                c.fillStyle = 'green';
            }
            c.fillRect(...bullet.point, 2, 2);
        }

    }



    function main(time) {
        if (c) {  /// is this needed?
            incrementModel(state);
            render(c, state);
        }
        if (state.running) {
            requestAnimationFrame(main);
        }
    }
    main();

</script>
</body>