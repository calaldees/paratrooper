<!-- Chrome Canvas Fullscreen - F11 to toggle fullscreen -->
<body style="margin: 0;">
<canvas id="canvas" width="480" height="270" style="image-rendering: pixelated; object-fit: contain; width:100%; max-width: 100%; height: 100%; max-height: 100%;">
</canvas>
<script type="module">



    // External functions copy&paste -------------------------------------------

    // https://stackoverflow.com/a/37319954/3356840
    function filterInPlace(a, condition, thisArg) {
        let j = 0;
        a.forEach((e, i) => {
            if (condition.call(thisArg, e, i, a)) {
                if (i!==j) a[j] = e;
                j++;
            }
        });
        a.length = j;
        return a;
    }

    // https://stackoverflow.com/a/28866825
    // doctest?! Explain
    function isIntersecting(p1, p2, p3, p4) {
        function CCW(p1, p2, p3) {
            //return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
            return (p3[1] - p1[1]) * (p2[0] - p1[0]) > (p2[1] - p1[1]) * (p3[0] - p1[0]);
        }
        return (CCW(p1, p3, p4) != CCW(p2, p3, p4)) && (CCW(p1, p2, p3) != CCW(p1, p2, p4));
    }



    // Setup? ------------------------------------------------------------------


    const canvas = document.getElementById('canvas');
    const c = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;


    function clearScreen(c) {
        c.fillStyle = 'black';
        c.fillRect(0, 0, w, h);
    }


    function loadBase64Images(base64, sprite_location_data, sprite_output) {
        const image = new Image();
        image.onload = function() {
            c.fillStyle = 'black';  // TODO transparent
            c.fillRect(0, 0, w, h);
            c.drawImage(image, 0, 0);
            for (let [name, location] of Object.entries(sprite_location_data)) {
                sprite_output[name] = c.getImageData(...location);
            }
        };
        image.src = "data:image/png;base64,"+base64;
    }

    const sprites = {};
    loadBase64Images(
        "iVBORw0KGgoAAAANSUhEUgAAAEoAAAAwCAYAAAC2aezWAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mSkWqDnYQcchQBcGCqIhjqWIRLJS2QqsOJpf+QZOGJMXFUXAtOPizWHVwcdbVwVUQBH9A3NycFF2kxO+SQosY7zju4b3vfbn7DhAaFaaaXZOAqllGKh4Ts7lVMfAKP/ppAuMSM/VEejEDz/F1Dx/f7yI8y7vuz9Gn5E0G+ETiKNMNi3iDeHbT0jnvE4dYSVKIz4knDLog8SPXZZffOBcdFnhmyMik5olDxGKxg+UOZiVDJZ4hDiuqRvlC1mWF8xZntVJjrXvyFwbz2kqa67RGEMcSEkhChIwayqjAQoR2jRQTKTqPefiHHX+SXDK5ymDkWEAVKiTHD/4Hv3trFqan3KRgDOh+se2PUSCwCzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjYGAbuLhua/IecLkDDD3pkiE5kp+WUCgA72f0TTlg8BboXXP71jrH6QOQoV4t3wAHh8BYkbLXPd7d09m3f2ta/fsBQINyk4GMT3IAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflAw4OHwGd4T5wAAABiElEQVRo3u1ay5LDMAgzmf1F9yPrj6SHJjPZ1EkMBrZeSzM9JAdhhPCroczMaUUhomQMb/4wrIlwSon3SY3CH4Vl/1CIkmcy3vyhrvKovDd/BH4sKv88PNPNXOTNH+oqyS/zJ6L5Q+eonrnncXhnmYw3fwuIMzMVIs7Mj+d7UL8GlK/HQ4X2rqklSSuPK/8w7Vdrl00gT/4wR23J0FpqqwEcK73F8OIPEUqLzS1U9IPm3CecJLY0Vk9eHxOq56QascK1xlikateW6KtlW1pFKb8mjjZGfaNyguOkyg17HG/+kBi1SrSQa8SK4veIQRK7ti40zCw+Znjz98YwT0abRAR/TwxVVS6X1M79jTd/VIx0tiltffcN/JoYpCG03D1781vFoDvSoe+5PY4wd6rPLpjoIDyzWOLT/KxiLQmAULbXDJJTdx74P7kosWYXCa1n6arpWw6OMnQV3ARH2bkKbroT648+hEDr/Zfbgz1wHyVAZh76e0u03re56awN4SgAQgEAAAAAIMUL9udvQPJcSDgAAAAASUVORK5CYII=",
        {
            jet1: [0,0,24,10],
            jet2: [24,0,24,10],
            heli1: [0,10,24,10],
            heli2: [24,10,24,10],
            heli3: [48,10,24,10],
            parachute: [0,20,12,14],
            trooper: [4,34, 4, 8],
        },
        sprites,
    );



    /*
    Design doc stuff
    Points are arrays of two elements e.g [x, y] -> [10, 87]
    */

    function isPointOutOfScreenBounds(point) {
        const [x, y] = point;
        return (x < 0 || x > w || y < 0 || y > w);
    }





    class Polygon {
        constructor() {
            this.points = [];
        }
        addPoint(point) {
            this.points.push([...point]);
        }
        * lines() {
            if (!this.points.length) {return;}
            let b = undefined;
            for (let a of this.points) {
                if (a && b) {
                    yield [a, b];
                }
                b = a;
            }
            yield [...b, ...this.points[0]];
        }
        isInside(point) {
            let intersections = 0;
            for (let line of this.lines()) {
                if (isIntersecting(...line, point, [-1, -2])) {  // kind of rubbish hard coding ... maybe use int.min?
                    intersections++;
                    //console.log("oow"); // something up here
                }
            }
            return intersections % 2;  // return 0 for no collision and 1 for collision
        }
        get Path2D() {
            //debugger;
            const p = new Path2D();
            if (!this.points.length) {return p;}
            // duplicated from lines? optimise
            let b = undefined;
            for (let a of this.points) {
                if (!b) {p.moveTo(...a)}
                else {p.lineTo(...a);}
                b = a ;
            }
            p.lineTo(...this.points[0]);
            return p;
        }
    }

    class Bullet {
        constructor(point, velocity) {
            this.point_current = [...point];
            this.point_previous = [...point];
            this.velocity = [...velocity];
        }
        get points() {
            return [this.point_current, this.point_previous];
        }
        get point() {
            return this.point_current;
        }
        get pointInt() {
            return this.point_current.map(Math.floor);
        }
        set point(point) {
            this.point_previous.splice(0,2, ...this.point_current);
            this.point_current.splice(0,2, ...point);
        }
        move() {
            this.point = [
                this.point_current[0] + this.velocity[0],
                this.point_current[1] + this.velocity[1],
            ];
        }
    }


    const screenPoly = new Polygon();
    for (let p of [
        [0,0],
        [50,0],
        [50,50],
        [0,50],
    ]) {
        screenPoly.addPoint(p);
    }
    


    const state = {
        running: true,
        frame: 0,
        input: {
        },
        gun: {
            pos: [w/2, h*0.80],
            length: 20,
            angle: Math.PI,
            angle_min: Math.PI - (Math.PI/2),
            angle_max: Math.PI + (Math.PI/2),
            fire: 0,
        },
        bullets: [],
        screen: screenPoly,
        xx: 50,
    };


    document.addEventListener('mouseup', () => state.gun.fire = 0, false);
    document.addEventListener('mousedown', () => state.gun.fire = state.frame, false);
    document.addEventListener("pointermove", (e) => {
        //console.log(-e.movementX, e.movementY);
        state.gun.angle -= e.movementX/180;
        state.gun.angle = Math.max(Math.min(state.gun.angle, state.gun.angle_max), state.gun.angle_min);
    }, false);


    function setRunning(running) {state.running = running; console.log("running", running); requestAnimationFrame(main);}
    window.addEventListener("focus", () => {setRunning(true)}, false);
    window.addEventListener("blur", () => {setRunning(false)}, false);


    //-----------

    function gun_tip_pos(gun) {
        const [x, y, length, angle] = [...gun.pos, gun.length, gun.angle];
        return [
            x + (Math.sin(angle) * length),
            y + (Math.cos(angle) * length),
        ];
    }

    //------------


    function incrementModel(state) {
        if (state.gun.fire && (state.frame - state.gun.fire) % 8 == 0) {
            const v = 1;
            const angle = state.gun.angle;
            state.bullets.push(
                new Bullet(
                    gun_tip_pos(state.gun), // used named params here?
                    [Math.sin(angle) * v, Math.cos(angle) * v],
                )
            );
        }

        for (let bullet of state.bullets) {bullet.move();}
        filterInPlace(state.bullets, (b) => !isPointOutOfScreenBounds(b.point));

        state.frame++;
    }
    function render(c, state) {
        clearScreen(c);


        c.strokeStyle = 'green';
        c.lineWidth = 2;
        c.stroke(state.screen.Path2D);

        // Gun
        const [x, y, length, angle] = [...state.gun.pos, state.gun.length, state.gun.angle];
        c.beginPath();
        c.strokeStyle = 'cyan';
        c.lineWidth = 5;
        c.moveTo(x, y);
        c.lineTo(
            x + Math.sin(angle) * length,
            y + Math.cos(angle) * length,
        );
        c.stroke();

        // Bullets
        for (let bullet of state.bullets) {
            c.fillStyle = 'white';
            if (state.screen.isInside(bullet.point)) {
                c.fillStyle = 'green';
            }
            c.fillRect(...bullet.pointInt, 2, 2);
        }
        
        c.fillText(state.bullets.length, 200, 200);

        if (sprites.jet1) {
            c.putImageData(sprites['jet1'], state.frame, 50);
        }

    }



    function main(time) {
        if (c) {  /// is this needed?
            incrementModel(state);
            render(c, state);
        }
        if (state.running) {
            requestAnimationFrame(main);
        }
    }
    main();

</script>
</body>