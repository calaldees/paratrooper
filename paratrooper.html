<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,....==" />
    <style>
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
            object-fit: cover;
            display: block;
            height: 100%; max-height: 100%;
            width:100%; max-width: 100%;
        }
    </style>
</head>
<body>
    <!-- Chrome Canvas Fullscreen - F11 to toggle fullscreen -->
    <canvas id="canvas" width="480" height="270"></canvas>
</body>
<script type="module">

    /*
Your Mission
Do not allow enemy paratroopers to land on either side of your gun base.
If four paratroopers land on one side of your base, they will overpower your defence and blow up your gun.
After you have survived the first round of helicopters, watch out for the jet bombers. Every jet pilot has a deadly aim!

Scoring
Helicopter or Jet 10 points
Enemy Paratrooper 5 points
bomb 30 points
Each bullet you fire costs you one point

    */


    // External functions copy&paste -------------------------------------------

    // https://stackoverflow.com/a/37319954/3356840
    function filterInPlace(a, condition, thisArg) {
        let j = 0;
        a.forEach((e, i) => {
            if (condition.call(thisArg, e, i, a)) {
                if (i!==j) a[j] = e;
                j++;
            }
        });
        a.length = j;
        return a;
    }


    function isObjectEmpty(obj) {return obj && Object.keys(obj).length === 0 && obj.constructor === Object;}  // https://stackoverflow.com/a/32108184


    function mod(n, m) {return ((n % m) + m) % m;}
    class Dimension {
        constructor(...dimensions) {
            this.dimensions = [...dimensions];
        }
        get width() {return this.dimensions[0];}
        get height() {return this.dimensions[1];}
        get size() {return this.dimensions.reduce((prev, current) => prev * current);}
        normalise_position(...position) {
            return [ // TODO: remove duplication? map?
                mod(position[0], this.dimensions[0]),
                mod(position[1], this.dimensions[1]),
            ];
        }
        index_to_position(i) {
            return [
                mod(i, this.width),
                mod(Math.floor(i/this.width), this.height),
            ];
        }
        position_to_index(...position) {
            const _position = this.normalise_position(...position);
            return (this.width * _position[1]) + _position[0];
        }
    }


    // Setup? ------------------------------------------------------------------


    const canvas = document.getElementById('canvas');
    const c = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    document.addEventListener('mouseup', () => state.gun.fire = 0, false);
    document.addEventListener('mousedown', () => state.gun.fire = state.frame, false);
    document.addEventListener("pointermove", (e) => {
        //console.log(-e.movementX, e.movementY);
        state.gun.angle -= e.movementX/180;
        state.gun.angle = Math.max(Math.min(state.gun.angle, state.gun.angle_max), state.gun.angle_min);
    }, false);

    function setRunning(running) {state.running = running; console.log("running", running); requestAnimationFrame(main);}
    window.addEventListener("focus", () => {setRunning(true)}, false);
    window.addEventListener("blur", () => {setRunning(false)}, false);


    function flipX(imageData) {
        const d = new Dimension(imageData.width, imageData.height);
        const _imageData = c.createImageData(imageData);
        for (let y=0 ; y<d.height; y++) {
            for (let x=0 ; x<d.width; x++) {
                const i = d.position_to_index(d.width-1-x, y);
                const _i = d.position_to_index(x, y);
                // copy in multiples of 4 as each pixel is 4 bytes RGBA
                _imageData.data.set(imageData.data.slice(i*4, (i+1)*4), _i*4);
            }
        }
        return _imageData;
    }
    function flipX_sprites(sprite_object) {
        // Take a sprite object with each key as a sprite. Flip all sprites and inset as new key with `_flipX` appended
        for (let key of Object.keys(sprite_object)) {
            sprite_object[`${key}_flipX`] = flipX(sprite_object[key]);
        }
    }

    function loadBase64Images(base64, sprite_location_data, sprite_output) {
        const image = new Image();
        image.onload = function() {
            c.fillStyle = 'rgba(0,0,0,255)';  // TODO transparent??
            c.fillRect(0, 0, w, h);
            c.drawImage(image, 0, 0);
            for (let [name, location] of Object.entries(sprite_location_data)) {
                sprite_output[name] = c.getImageData(...location);
            }

            flipX_sprites(sprite_output);
            loadComplete();
        };
        image.src = base64;
    }

    const sprites = {};
    loadBase64Images(
        "data:image/gif;base64,R0lGODlhSgAwAMIDAAAAAP9V/1X//////////////////////yH5BAEKAAQALAAAAABKADAAAAP+KErc/lAJSKu9VAAwcdWcJ47ZFpINeKIspnbs286fyUm4NOyDo945HK832o1+tiRn6FM6lzwR04N8bgRTQtWKjWKylQAh8AuYz2ZTjkG2odFqnMd4tHLHjK19RXuItUGBcg1igoYwfTNmJG+NbxeOjy10NJQzlhR/FENgmhWcXoQXoJhspDw2nA4Bpzupna0Dr6FsDpxOqqIEt0q5eAy8Sb5fdkSjxXPIRU/GxLjLzyin0qTUoDOI2SLaKds+3xaHax/iEuHlCxHmieyJgu3wKIfx9Bfl9fgP9/n8+/z4niAE/BdvYC0LYAiKMPhr0zCFHgYy3FUN4kKBCM3s0GhTcYSniRSvdYy4CmHIKM1GhjnoEJiXUiofwJS5S0GPlDFbzqG4K6eLdV+A+aSC6AvOoepIzESap+nOnkwzOEXYbKnPDkU32YrKtavXr2DDih3rMwEAOw==",
        {
            jet1: [0,0,24,10],
            jet2: [24,0,24,10],
            heli1: [0,10,24,10],
            heli2: [24,10,24,10],
            heli3: [48,10,24,10],
            parachute: [0,20,12,14],
            trooper: [4,34, 4, 8],
            trooper_dead: [17,27, 12, 15],
            bomb: [59, 4, 4, 4],
        },
        sprites,
    );



    /*
    Design doc stuff
    Points are arrays of two elements e.g [x, y] -> [10, 87]
    */


    // Objects -----------------------------------------------------------------

    class AbstractGameObject {
        constructor(point, velocity) {
            this.point_current = [...point];
            this.velocity = [...velocity];
        }
        get point() {
            return this.point_current;
        }
        get pointInt() {
            return this.point_current.map(Math.floor);
        }
        set point(point) {
            this.point_current.splice(0,2, ...point);
        }
        get isOutOfScreenBounds() {
            const [x, y] = this.point;
            return (x < 0 || x > w || y < -20 || y > w);
        }
        move() {
            this.point = [
                this.point_current[0] + this.velocity[0],
                this.point_current[1] + this.velocity[1],
            ];
        }
    }


    class Bullet extends AbstractGameObject {
        constructor(point, velocity) {
            super(point, velocity);
            this.point_previous = [...point];
        }
        get points() {
            return [this.point_current, this.point_previous];
        }
        get point() {
            return this.point_current;
        }
        set point(point) {
            this.point_previous.splice(0,2, ...this.point_current);
            this.point_current.splice(0,2, ...point);  // duplicated in super? how call super? how?
        }
    }

    class Particle extends AbstractGameObject {
        constructor(point, velocity, color) {
            super(point, velocity);
            this.color = color;
        }
        move() {
            super.move();
            this.velocity[1] = this.velocity[1] + 0.08;
        }
    }

    class TimedSprite extends AbstractGameObject {
        constructor(point, sprite, time_to_live=60) {
            super(point, [0, 0]);
            this.sprite = sprite;
            this.time_to_live = time_to_live;
        }
        get alive() {
            return (this.time_to_live>0);
        }
        move() {
            super.move();
            this.time_to_live--;
        }
    }

    class AbstractEnemy extends AbstractGameObject {
        constructor(point, velocity) {
            super(point, velocity);
            //this.bounds /// abstract
        }
        //get sprite() {}  // abstract
        // This may not be sufficient for fast moving bullets ... we may need line crossing?
        isPointInBounds(point) {
            const [px, py] = point;
            const [ix, iy] = this.point;
            const [iw, ih] = this.bounds;
            return (px>=ix && px<=ix+iw && py>=iy && py<=iy+ih);
        }
        * particles(velocity=[0,0]) {
            const s = this.sprite;
            const d = new Dimension(s.width, s.height);
            for (let i=0 ; i<s.data.length ; i+=4) {
                const c = s.data.slice(i, i+4);
                if (c[3]<255 || (c[0]==0 && c[1]==0 && c[2]==0)) {continue;}  // non solid colors do not create particles
                const [x, y] = d.index_to_position(i);
                yield new Particle(
                    [
                        x + this.point[0],
                        y + this.point[1],
                    ],
                    [
                        this.velocity[0] + velocity[0]*0.8 + (Math.random() - 0.5),
                        this.velocity[1] + velocity[1]*0.8 + (Math.random() - 0.5),
                    ],
                    `rgb(${c[0]},${c[1]},${c[2]})`,
                );
            }
        }
    }


    class AbstractEnemyAnimated extends AbstractEnemy {
        constructor(point, velocity, sprite_names) {
            super(point, velocity);
            this.sprites_left = sprite_names.map((name)=>sprites[name]);
            this.sprites_right = sprite_names.map((name)=>sprites[`${name}_flipX`]);
            this.bounds = [this.sprites_left[0].width, this.sprites_left[0].height];
            this.payloads = [];
        }
        get sprite() {
            const frame = mod(Math.floor(this.point[0] / 4), this.sprites_left.length);
            return (this.velocity[0]>0 ? this.sprites_left : this.sprites_right)[frame];
        }
        get expired() {
            // has object left edge of screen?
            return this.velocity[0] > 0 ? this.point[0] > w : this.point[0] < 0;
        }
        get payload() {
            const x = this.point[0];
            let _p = undefined;
            filterInPlace(this.payloads, function(p){
                if (Math.abs(x - p.point[0]) < 3) {_p = p; return false;}
                return true;
            })
            return _p;
        }
    }


    class Jet extends AbstractEnemyAnimated {
        constructor(point, velocity, number_of_bombs=1) {
            super(point, velocity, ['jet1', 'jet2']);
            if (Math.random()>0.5) {
                const v = this.velocity[0];
                this.payloads.push(new Bomb([v>0?100:w-100, this.point[1]], this.velocity));
            }
        }
    }

    class Heli extends AbstractEnemyAnimated {
        constructor(point, velocity, number_of_paratroopers=2) {
            super(point, velocity, ['heli1', 'heli2', 'heli3']);
            for (let t=0 ; t<number_of_paratroopers ; t++) {
                this.payloads.push(new Paratrooper([Math.floor(Math.random()*w), point[1]], [0, 1]));
            }
        }
    }

    class Paratrooper extends AbstractEnemy {
        constructor(point, velocity) {
            super(point, velocity);
            this.sprites = {};  // TODO
            this.bounds = [4, 8]; //TODO? from sprite?
            this.parachute_threshold = point[1] + (Math.random() * h/4) + h/8;
        }
        get sprite() {
            return sprites['trooper'];
        }
        get parachuteOpen() {
            return (
                this.parachute_threshold > 0 &&
                this.point[1] > this.parachute_threshold
            );
        }
        isPointInBounds(point) {
            if (this.parachuteOpen) {
                // Do additional collision detection for parachute?
                const [px, py] = point;
                const [ix, iy] = [this.point[0]-4, this.point[1]-14];  // hard coded offset - same as render
                const [iw, ih] = [sprites['parachute'].width, sprites['parachute'].height];
                const parachuteHit = (px>=ix && px<=ix+iw && py>=iy && py<=iy+ih);
                if (parachuteHit) {
                    this.parachute_threshold = -1;
                }
            }
            return super.isPointInBounds(point);
        }
        move() {
            if (this.parachuteOpen) {
                this.velocity[1] = Math.max(this.velocity[1]+=-0.1, 0.5);
            } else {
                this.velocity[1] = Math.max(this.velocity[1]+=0.08, 0.8);
            }
            super.move();
        }
    }

    class Bomb extends AbstractEnemy {
        constructor(point, velocity) {
            super(point, velocity);
            this._sprite = sprites['bomb'];
            this.bounds = [4, 4];  // TODO: from sprite?
        }
        get sprite() {
            return this._sprite;
        }
        move() {
            this.velocity[1] = Math.min(this.velocity[1]+=0.03, 1.5);
            super.move();
        }
    }


    // State -------------------------------------------------------------------

    const state = {
        running: true,
        frame: 0,
        input: {
        },
        ground: h - 20,
        gun: {
            pos: [w/2, h-24-20],
            width: 32,
            velocity: 3,
            length: 12,
            angle: Math.PI,
            angle_min: Math.PI - (Math.PI/2),
            angle_max: Math.PI + (Math.PI/2),
            fire: 0,
        },
        enemies: {
            jet: [],
            heli: [],
            paratrooper: [],
            trooper: [],
            bomb: [],
        },
        particles: [],
        bullets: [],
        timed_sprites: [],
        level: 0,
        score: 0,
    };


    function setupLevelEnemies(state) {
        const level = state.level;
        const level_length = Math.floor((Math.random() * level * 5) + (w * 2));
        const num_heli = Math.floor(Math.min(level * 1, 50));
        const num_jets = Math.floor(Math.min(level * 1, 20));
        const num_troops = Math.floor(Math.min(level * 1, 100));
        function random_start_x() {
            let x = Math.random() * level_length;
            if (Math.random() >= 0.5) {x += w;}
            else                      {x = x * -1;}
            return Math.floor(x);
        }
        for (let i=0 ; i<num_heli ; i++) {
            const x = random_start_x();
            state.enemies.heli.push(new Heli([x, 44], [x>w?-1:1, 0], Math.floor(Math.random()*5)+1 ));
        }
        for (let i=0 ; i<num_heli ; i++) {
            const x = random_start_x();
            state.enemies.jet.push(new Jet([x, 30], [x>w?-1:1, 0]));
        }

    }




    //-----------

    function gun_tip_pos(gun) {
        const [x, y, length, angle] = [...gun.pos, gun.length, gun.angle];
        return [
            x + (Math.sin(angle) * length),
            y + (Math.cos(angle) * length),
        ];
    }

    //------------

    function reset() {
        state.level = 0;
        state.score = 0;
        for (let key of Object.keys(state.enemies)) {
            state.enemies[key].length = 0;
        }
    }

    function incrementModel(state) {
        // End level
        if (state.enemies.jet.length + state.enemies.heli.length <= 0) {
            state.level++;
            setupLevelEnemies(state);
        }

        // Game over
        const troops_left = state.enemies.trooper.filter((t)=>t.point[0] > state.gun.pos[0]).length;
        const troops_right = state.enemies.trooper.filter((t)=>t.point[0] < state.gun.pos[0]).length;
        if (troops_left>4 || troops_right>4) {
            reset();
        }
        for (let bomb of state.enemies.bomb) {
            if (bomb.point[1] > state.gun.pos[1]) {
                reset();
            }
        }


        // Fire Gun
        if (state.gun.fire && (state.frame - state.gun.fire) % 8 == 0) {
            const velocity = state.gun.velocity;
            const angle = state.gun.angle;
            state.score = Math.max(0, state.score-1);
            state.bullets.push(
                new Bullet(
                    gun_tip_pos(state.gun), // used named params here?
                    [Math.sin(angle) * velocity, Math.cos(angle) * velocity],
                )
            );
        }

        // Move
        for (let game_object of [
            ...state.enemies.jet,
            ...state.enemies.heli,
            ...state.enemies.paratrooper,
            ...state.enemies.bomb,
            ...state.bullets,
            ...state.particles,
            ...state.timed_sprites,
        ]) {game_object.move();}

        // Launch Paratroopers
        for (let heli of state.enemies.heli) {
            let paratrooper = heli.payload;
            if (paratrooper) {
                state.enemies.paratrooper.push(paratrooper);
            }
        }

        // Launch Bombs
        for (let jet of state.enemies.jet) {
            let bomb = jet.payload;
            if (bomb) {
                state.enemies.bomb.push(bomb);
            }
        }

        // Bullets
        filterInPlace(state.timed_sprites, (s) => s.alive);
        filterInPlace(state.bullets, (b) => !b.isOutOfScreenBounds);
        filterInPlace(state.particles, (p) => !p.isOutOfScreenBounds);
        filterInPlace(state.enemies.paratrooper, function (pt) {
            for (let b of state.bullets) {
                if (pt.isPointInBounds(b.point)) {
                    for (let p of pt.particles(b.velocity)) {state.particles.push(p);}
                    state.score += 5;
                    return false;
                }
            }
            if (pt.point[1] > state.ground) {
                if (pt.velocity[1] < 1) {
                    state.enemies.trooper.push(pt);
                }
                else {
                    state.timed_sprites.push(
                        new TimedSprite(pt.point, sprites['trooper_dead'])
                    );
                    filterInPlace(state.enemies.trooper, (t) => Math.abs(t.point[0] - pt.point[0]) > 5);
                }
                return false;
            }
            return true;
        });
        filterInPlace(state.enemies.jet, function (j) {
            for (let b of state.bullets) {
                if (j.isPointInBounds(b.point)) {
                    for (let p of j.particles(b.velocity)) {state.particles.push(p);}
                    state.score += 10;
                    return false;
                }
            }
            return !j.expired;
        });
        filterInPlace(state.enemies.heli, function (h) {
            for (let b of state.bullets) {
                if (h.isPointInBounds(b.point)) {
                    for (let p of h.particles(b.velocity)) {state.particles.push(p);}
                    state.score += 8;
                    return false;
                }
            }
            return !h.expired;
        });
        filterInPlace(state.enemies.bomb, function (bo) {
            for (let b of state.bullets) {
                if (bo.isPointInBounds(b.point)) {
                    for (let p of bo.particles(b.velocity)) {state.particles.push(p);}
                    state.score += 15;
                    return false;
                }
            }
            return true;
        });


        state.frame++;
    }


    function render(c, state) {
        c.fillStyle = 'black';
        c.fillRect(0, 0, w, h);

        // Side buffers
        c.fillStyle = 'magenta';
        c.fillRect(0, h-60, 60, 60);
        c.fillRect(w-60, h-60, 60, 60);
        // Ground
        c.strokeStyle = 'cyan';
        c.lineWidth = 2;
        c.beginPath();
        c.moveTo(0, state.ground);
        c.lineTo(w, state.ground);
        c.stroke();

        
        function drawGun(gun) {
            const [x, y, length, angle, width] = [...gun.pos, gun.length, gun.angle, Math.floor(gun.width/2)];
            c.lineCap = "round";
            // Gun Barrel
            c.beginPath();
            c.strokeStyle = 'cyan';
            c.lineWidth = 4;
            c.moveTo(x, y);
            c.lineTo(
                x + Math.sin(angle) * length,
                y + Math.cos(angle) * length,
            );
            c.stroke();
            // Gun Turret
            c.beginPath();
            c.strokeStyle = 'magenta';
            c.lineWidth = 8;
            c.moveTo(x, y);
            c.lineTo(x, y+16);
            c.stroke();
            // Gun Base
            c.fillStyle = 'white';
            c.fillRect(x-width, y, width*2, state.ground-y);

        }
        drawGun(state.gun);


        c.fillStyle = 'white';
        c.fillText(`Level: ${state.level}`, 80, h-6);
        c.fillText(`Score: ${state.score}`, 160, h-6);



        // Bullets
        for (let bullet of state.bullets) {
            c.fillStyle = 'white';
            c.fillRect(...bullet.pointInt, 2, 2);
        }
        
        for (let p of state.particles) {
            c.fillStyle = p.color;
            c.fillRect(...p.pointInt, 1, 1);
        }

        for (let game_object of [
            ...state.enemies.jet,
            ...state.enemies.heli,
            ...state.enemies.paratrooper,
            ...state.enemies.trooper,
            ...state.timed_sprites,
            ...state.enemies.bomb,
        ]) {
            c.putImageData(game_object.sprite, ...game_object.point);
        }
        // draw parachutes separately
        for (let paratrooper of state.enemies.paratrooper){
            if (paratrooper.parachuteOpen) {
                c.putImageData(sprites['parachute'], paratrooper.point[0]-4, paratrooper.point[1]-14);
            }
        }

    }


    function loadComplete() {
        main();
    }

    function main(time) {
        if (c) {  /// is this needed?
            incrementModel(state);
            render(c, state);
        }
        if (state.running) {
            requestAnimationFrame(main);
        }
    }

</script>
</html>