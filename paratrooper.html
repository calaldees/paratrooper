<!-- Chrome Canvas Fullscreen - F11 to toggle fullscreen -->
<body style="margin: 0;">
<canvas id="canvas" width="480" height="270" style="image-rendering: pixelated; object-fit: contain; width:100%; max-width: 100%; height: 100%; max-height: 100%;">
</canvas>
<script type="module">



    // External functions copy&paste -------------------------------------------

    // https://stackoverflow.com/a/37319954/3356840
    function filterInPlace(a, condition, thisArg) {
        let j = 0;
        a.forEach((e, i) => {
            if (condition.call(thisArg, e, i, a)) {
                if (i!==j) a[j] = e;
                j++;
            }
        });
        a.length = j;
        return a;
    }


    function isObjectEmpty(obj) {return obj && Object.keys(obj).length === 0 && obj.constructor === Object;}  // https://stackoverflow.com/a/32108184


    function mod(n, m) {return ((n % m) + m) % m;}
    class Dimension {
        constructor(...dimensions) {
            this.dimensions = [...dimensions];
        }
        get width() {return this.dimensions[0];}
        get height() {return this.dimensions[1];}
        get size() {return this.dimensions.reduce((prev, current) => prev * current);}
        normalise_position(...position) {
            return [ // TODO: remove duplication? map?
                mod(position[0], this.dimensions[0]),
                mod(position[1], this.dimensions[1]),
            ];
        }
        index_to_position(i) {
            return [
                mod(i, this.width),
                mod(Math.floor(i/this.width), this.height),
            ];
        }
        position_to_index(...position) {
            const _position = this.normalise_position(...position);
            return (this.width * _position[1]) + _position[0];
        }
    }


    // Setup? ------------------------------------------------------------------


    const canvas = document.getElementById('canvas');
    const c = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    document.addEventListener('mouseup', () => state.gun.fire = 0, false);
    document.addEventListener('mousedown', () => state.gun.fire = state.frame, false);
    document.addEventListener("pointermove", (e) => {
        //console.log(-e.movementX, e.movementY);
        state.gun.angle -= e.movementX/180;
        state.gun.angle = Math.max(Math.min(state.gun.angle, state.gun.angle_max), state.gun.angle_min);
    }, false);

    function setRunning(running) {state.running = running; console.log("running", running); requestAnimationFrame(main);}
    window.addEventListener("focus", () => {setRunning(true)}, false);
    window.addEventListener("blur", () => {setRunning(false)}, false);



    function clearScreen(c) {
        c.fillStyle = 'black';
        c.fillRect(0, 0, w, h);
    }


    function flipX(imageData) {
        const d = new Dimension(imageData.width, imageData.height);
        const _imageData = c.createImageData(imageData);
        for (let y=0 ; y<d.height; y++) {
            for (let x=0 ; x<d.width; x++) {
                const i = d.position_to_index(d.width-1-x, y);
                const _i = d.position_to_index(x, y);
                // copy in multiples of 4 as each pixel is 4 bytes RGBA
                _imageData.data.set(imageData.data.slice(i*4, (i+1)*4), _i*4);
            }
        }
        return _imageData;
    }

    function loadBase64Images(base64, sprite_location_data, sprite_output) {
        const image = new Image();
        image.onload = function() {
            c.fillStyle = 'black';  // TODO transparent
            c.fillRect(0, 0, w, h);
            c.drawImage(image, 0, 0);
            for (let [name, location] of Object.entries(sprite_location_data)) {
                sprite_output[name] = c.getImageData(...location);
            }

            loadComplete();
        };
        image.src = base64;
    }

    const sprites = {};
    loadBase64Images(
        "data:image/gif;base64,R0lGODlhSgAwAMIDAAAAAP9V/1X//////////////////////yH5BAEKAAQALAAAAABKADAAAAP+KErc/lAJSKu9VAAwcdWcJ47ZFpINeKIspnbs286fyUm4NOyDo945HK9Hu/xsSM7Ql2wqeUXL0bkRLBlTqhUadQQIgV9gTB6bcoywrVw+47oRqhaMlTthcDohyEc3vn2BeHkjYyRsiGwXiYotO1GPRZEWXxVDV2kYl1x/F5uTXp88NpehogOkmGCnqCalXg6XTa+ZBLJJtJW2Q7OqnnJEv1TBFq1OxJrHI8ZIyMXKKKLRn9ObM3jYItkp2j7eUoJvH+ES4OSDWOWE6yN97O/j7vDze+H08OT37/n667oU//rBCdipGCeBGAjWomANoQeCChlIc7gIQkRbY3ZkpJhMEJbBhhwr/LvYw5qzkAVJErkCCmWskw9KKijp0qCIkjRrZlCnSaJOcCRa/vSBzubQCFhu+jz6rejLp0z3JO3ZAGbUq1izat3KtSvXBAA7",
        {
            jet1: [0,0,24,10],
            jet2: [24,0,24,10],
            heli1: [0,10,24,10],
            heli2: [24,10,24,10],
            heli3: [48,10,24,10],
            parachute: [0,20,12,14],
            trooper: [4,34, 4, 8],
            // skull death?
        },
        sprites,
    );



    /*
    Design doc stuff
    Points are arrays of two elements e.g [x, y] -> [10, 87]
    */

    function isPointOutOfScreenBounds(point) {
        const [x, y] = point;
        return (x < 0 || x > w || y < -20 || y > w);
    }


    // Objects -----------------------------------------------------------------

    class AbstractGameObject {
        constructor(point, velocity) {
            this.point_current = [...point];
            this.velocity = [...velocity];
        }
        get point() {
            return this.point_current;
        }
        get pointInt() {
            return this.point_current.map(Math.floor);
        }
        set point(point) {
            this.point_current.splice(0,2, ...point);
        }
        move() {
            this.point = [
                this.point_current[0] + this.velocity[0],
                this.point_current[1] + this.velocity[1],
            ];
        }
    }


    class Bullet extends AbstractGameObject {
        constructor(point, velocity) {
            super(point, velocity);
            this.point_previous = [...point];
        }
        get points() {
            return [this.point_current, this.point_previous];
        }
        get point() {
            return this.point_current;
        }
        set point(point) {
            this.point_previous.splice(0,2, ...this.point_current);
            this.point_current.splice(0,2, ...point);  // duplicated in super? how call super? how?
        }
    }

    class Particle extends AbstractGameObject {
        constructor(point, velocity, color) {
            super(point, velocity);
            this.color = color;
        }
    }

    class AbstractEnemy extends AbstractGameObject {
        constructor(point, velocity, sprite_names) {
            super(point, velocity);
            // NO NO NO!! Every construction flips the sprites? WFT! NO!!
            this.sprites_left = sprite_names.map((name)=>sprites[name]);
            this.sprites_right = this.sprites_left.map(flipX);
            this.bounds = [this.sprites_left[0].width, this.sprites_left[0].height];
        }
        get sprite() {
            const frame = Math.floor(this.point[0] / 4) % this.sprites_left.length;
            return (this.velocity[0]>0 ? this.sprites_left : this.sprites_right)[frame];
        }
        isPointInBounds(point) {
            const [px, py] = point;
            const [ix, iy] = this.point;
            const [iw, ih] = this.bounds;
            return (px>=ix && px<=ix+iw && py>=iy && py<=iy+ih);
        }
        getParticles() {
            this.sprite; // TODO create/yield? particles
        }
    }

    class Jet extends AbstractEnemy {
        constructor(point, velocity) {
            super(point, velocity, ['jet1', 'jet2']);
        }
    }

    class Heli extends AbstractEnemy {
        constructor(point, velocity) {
            super(point, velocity, ['heli1', 'heli2', 'heli3']);
        }
    }

    class Paratrooper extends AbstractEnemy {
        constructor(point, velocity) {
            super(point, velocity, ['trooper']);
        }
    }



    // State -------------------------------------------------------------------

    const state = {
        running: true,
        frame: 0,
        input: {
        },
        ground: h - 20,
        gun: {
            pos: [w/2, h*0.80],
            length: 20,
            angle: Math.PI,
            angle_min: Math.PI - (Math.PI/2),
            angle_max: Math.PI + (Math.PI/2),
            fire: 0,
        },
        enemies: {
            jet: [],
            heli: [],
            paratrooper: [],
            trooper: [],
            bomb: [],
        },
        particles: [],
        bullets: [],
        level: 1,
    };


    function setupLevelEnemies(state) {
        const level = state.level;
        const num_heli = Math.floor(Math.max(level * 0.5, 50));
        const num_jets = Math.floor(Math.max(level * 0.5, 20));
        for (let i=0 ; i<num_heli ; i++) {

        }

        state.enemies.jet.push(new Jet([0,30], [1,0]));
        state.enemies.heli.push(new Heli([w, 44], [-1,0]));
        state.enemies.paratrooper.push(new Paratrooper([100,0], [0,1]));
    }




    //-----------

    function gun_tip_pos(gun) {
        const [x, y, length, angle] = [...gun.pos, gun.length, gun.angle];
        return [
            x + (Math.sin(angle) * length),
            y + (Math.cos(angle) * length),
        ];
    }

    //------------


    function incrementModel(state) {
        // Fire Gun
        if (state.gun.fire && (state.frame - state.gun.fire) % 8 == 0) {
            const v = 1;
            const angle = state.gun.angle;
            state.bullets.push(
                new Bullet(
                    gun_tip_pos(state.gun), // used named params here?
                    [Math.sin(angle) * v, Math.cos(angle) * v],
                )
            );
        }

        // Move
        for (let game_object of [
            ...state.enemies.jet,
            ...state.enemies.heli,
            ...state.enemies.paratrooper,
            ...state.bullets,
            ...state.particles,
        ]) {game_object.move();}

        // Bullets
        filterInPlace(state.bullets, (b) => !isPointOutOfScreenBounds(b.point));
        filterInPlace(state.enemies.paratrooper, function (p) {
            if (p.point[1] > state.ground) {
                if (p.velocity[1] <= 1) {
                    state.enemies.trooper.push(p);
                }
                else {
                    //die?
                }
                return false;
            }
            return true;
        });
        filterInPlace(state.enemies.jet, function (j) {
            for (let b of state.bullets) {
                if (j.isPointInBounds(b.point)) {
                    return false;
                }
            }
            return true;
        });
        filterInPlace(state.enemies.heli, function (h) {
            for (let b of state.bullets) {
                if (h.isPointInBounds(b.point)) {
                    return false;
                }
            }
            return true;
        });

        state.frame++;
    }


    function render(c, state) {
        clearScreen(c);


        // Gun
        const [x, y, length, angle] = [...state.gun.pos, state.gun.length, state.gun.angle];
        c.beginPath();
        c.strokeStyle = 'cyan';
        c.lineWidth = 4;
        c.moveTo(x, y);
        c.lineTo(
            x + Math.sin(angle) * length,
            y + Math.cos(angle) * length,
        );
        c.stroke();

        // Bullets
        for (let bullet of state.bullets) {
            c.fillStyle = 'white';
            c.fillRect(...bullet.pointInt, 2, 2);
        }
        
        c.fillText(state.bullets.length, 200, 200);

        for (let enemy of [
            ...state.enemies.jet,
            ...state.enemies.heli,
            ...state.enemies.paratrooper,
            ...state.enemies.trooper,
        ]) {
            c.putImageData(enemy.sprite, ...enemy.point);
        }

    }


    function loadComplete() {
        setupLevelEnemies(state);
        main();
    }

    function main(time) {
        if (c) {  /// is this needed?
            incrementModel(state);
            render(c, state);
        }
        if (state.running) {
            requestAnimationFrame(main);
        }
    }

</script>
</body>